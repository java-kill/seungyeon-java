# ch02. 변수

## 1. 변수

> 변수란, 단 하나의 값을 저장할 수 있는 메모리 공간(RAM)
<details>
    </br>
    <summary>변수와 메모리 주소</summary>
    메모리 주소를 이용해 값을 저장하는데, (메모리 주소는 기억하기 어려우니까)거기에 이름을 붙여 읽기 쉽게 한 것, 그게 변수
</details>

### 변수 선언
> 변수타입 변수이름;
<details>
    </br>
    <summary><strong>변수 선언하는 이유</strong></summary>
    값(data)을 저장할 공간을 마련하기 위해
</details>

### 변수의 초기화

> 변수의 초기화란, 변수를 사용하기 전에 처음으로 값을 저장하는 것 </br>
> 변수타입 변수이름 = 값;

모든 변수는 사용하기 전에 적절한 값으로 초기화하는 것이 좋다.</br>
*지역 변수는 읽기 전에 꼭! 초기화해야 한다. 그렇지 않으면, 컴파일 시 에러 발생*

<details>
    </br>
    <summary>변수를 초기화해야하는 이유</summary>
    <p>내가 원하는 값(새로운 값)으로 변수를 사용하기 위해 어디서 사용했을지도 모르는 변수의 알 수 없는 값을 지우기 위해 </p>
</details>

### 변수의 명명규칙
> '변수의 이름'처럼 프로그래밍에서 사용하는 모든 이름을 "식별자"라고 한다.

## 2. 변수의 타입
변수의 타입은 저장할 값의 타입에 의해 결정된다.

###자료형(data type)
값의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것

#### 1) 기본형

- 계산을 위해 실제 값(data)를 저장
- 모두 8개
  - 논리형 - boolean : 1byte
  - 문자형 - char : 2byte
  - 정수형 - byte, short, int(기본), long :1/2/4/8 byte
  - 실수형 - float, double(기본) : 4/8byte

#### 2) 참조형

- null 또는 객체의 주소(4 or 8 byte)를 값으로 가진다.
- 8개의 기본형 변수를 사용하여 사용자가 직접 만들어 사용하는 변수
- 연산불가
- 8개의 기본형을 제외한 나머지 타입 ex) String, Stream

참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로, 클래스의 이름이 참조변수의 타입이 된다.
> 클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다. </br>
> ex) Date today = new Date();

객체를 생성하는 연산자 new의 결과는 생성된 객체의 주소이다. 이 주소가 대입연산자'='에 의해서 참조변수에 저장되는 것이다.

## 상수
> 변하지 않는 변수 (메모리의 주소값이 변하지 않는다)
- 변수 타입 앞에 final 붙여서 사용
- 반드시 선언과 동시에 초기화해야한다.
- 이름은 대문자로 하며, '_' 사용하여 구분

### 리터럴
> 데이터 그 자체. = 변수의 값이 변하지 않는 데이터(메모리 안의 값)

### 리터럴 타입과 접미사
- 정수형 L(long타입) ex) 100L
- 실수형 f(float),d(double) 기본자료형이라 생략가능
- char 문자하나면 작은따옴표('')로 묶어줌
- String 문자열은 큰따옴표(" ")로 묶어줌
 
*저장범위 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.*

##printf()
지시자
* %b(boolean)
* %d(10진 정수), 정수 출력
* %o(8진 정수)
* %x/%X(16진 정수)
* %f(부동 소수점), 소수점 아래 6자리까지
* %e/%E(지수)
* %c(문자)
* %s(문자열)
* %n, \n(개행)
* Integer.toBinaryString : 정수를 2진수로 변환

- 지시자 앞에 '#'을 붙이면 접두사 출력됨
```java
System.out.printf("%#x", 15); //0xf
```

## 오버플로우
> 타입이 표현할 수 있는 값의 범위를 넘어서는 것

### 정수형의 오버플로우
* 최대값 + 1 -> 최소값
* 최소값 - 1 -> 최대값

### 실수형의 오버플로우
실수형에서 오버플로우 발생하면 변수의 값으 *"무한대"*
> 언더플로우, 실수형으로 표현할 수 없는 아주 작은 값. 최소값보다 작은 값이 되는 경우 -> 값 0

실수형은 오차가 발생할 수 있는 단점이 있기 때문에 '높은 정밀도'를 필요로 한다.

## 형변환
> 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
<details>
    </br>
    <summary><strong>형변환을 하는 이유</strong></summary>
    서로 다른 두 타입을 일치시키기 위해 ex)연산
</details>

### 형변환 방법(캐스팅)
> (타입)피연산자

### 자동형변환
<details>
    </br>
    <summary><strong>컴파일러가 타입을 일치시키는 기준</strong></summary>
    기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환을 한다.</br>
    보통 좁은 쪽에서 < 넓은 쪽으로 해야 손실이 없다. </br>
    byte -> short -> int -> long -> char -> double </br>
            char -> int
</details>


1. boolean 제외 기본형끼리는 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변활 할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만,
값의 밤위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.

