# ch06. 객체지향 개념1

<details>
    </br>
    <summary>객체지향(oop) 핵심적 특징은?(4가지)</summary>
    1. 캡슐화</br>
    2. 상속</br>
    3. 추상화</br>
    4. 다형성
</details>

## 클래스와 객체
### 클래스
> 객체를 정의해 놓은 것 (제품 설계도)
<details>
    </br>
    <summary>클래스가 왜 필요한가?</summary>
    객체를 생성하기 위해</br>
    제품설계도는 제품을 만들기 위해 필요한 것처럼.
</details>

### 객체
> 실제로 존재하는 것
```java
class Tv {
    //변수
    String color;
    boolean power;
    int channel;
    //메서드
    void power() {power =! power;}
    void channelUp() { channel++;}
    void channelDown() { channel--;}
}
```
> 속성(변수) + 기능(메서드)

<details>
    <summary>객체가 왜 필요한가?</summary>
    객체를 사용하기 위해</br>
    우리가 제품을 사용하려고.
</details>
</br>
<details>
    <summary>객체를 사용한다는 것은?</summary>
    객체가 가진 속성과 기능을 사용한다는 것
</details>

### 인스턴스
> 객체와 비슷하지만, 클래스로부터 생성된 객체를 주로 말한다. ex) Tv인스턴스

객체는 모든 인스턴스를 대표하는 일반적 용어

### 하나의 소스파일에 여러 클래스를 작성할 경우
1. public class와 소스파일명은 반드시 일치해야 한다.(대소문자까지 일치해야한다.)
- 그러나 public class가 없을 경우에는 class 이름 중 하나랑만 일치하면 된다.
2. 하나의 소스파일에는 반드시 한개의 public class가 존재해야하며, 하나여야한다.

- 가능하면 한 개의 소스파일엔 하나의 class가 있는 것이 좋긴 함!

## 객체의 생성과 사용
```java
//객체 생성
Tv t; //클래스명 변수명 : 클래스의 객체를 참조하기 위한 참조변수를 선언
t = new Tv(); //변수명 = new 클래스명(); :클래스의 객체를 생성한 후, 객체의 주소를 참조변수에 저장
//객체 사용
t.channel = 7; //Tv인스턴스의 멤버변수 channel의 값을 7로 한다.
t.channelDown(); //Tv인스턴스의 메서드 channelDown()을 호출한다.
```
- Tv(클래스)의 참조변수 t(리모콘)과 new Tv(객체)를 연결(=)힌다. => Tv t = new Tv();
- 하나의 인스턴스를 여러 갸의 참조변수가 가리키는 경우(가능)
- 여러 인스턴스를 하나의 참조변수가 가리키는 경우(불가능)

## 객체 배열
객체 배열 == 참조변수 배열
```java
//객체배열
Tv[] tvArr = new Tv[3]; //Tv타입 참조변수tvArr 3개
tvArr[0] = new Tv();
tvArr[1] = new Tv(); 
tvArr[2] = new Tv();
```
- 객체배열은 단순히 참조배열이기때문에, 객체를 만들어야 사용가능하다.

------

## 클래스
1. 설계도
2. 데이터 + 함수
3. 사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다.

< 다시 짚고 넘어가기 >
- 변수 : 하나의 데이터를 저장할 수 있는 공간
- 배열 : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간(같은 타입만 가능)
- 구조체 : 서로 관련된 여러 데이터(종류 관계X)를 하나로 저장할 수 있는 공간(다른 타입 가능, 서로 관계 있는 것들만)
- 클래스 : 데이터화 함수의 결합 : 구조체(변수) + 함수(메서드)

## 선언 위치에 따른 변수의 종류
```java
class Card{
    //개별 속성인 인스턴스 변수
    String kind;
    int number;
    
    //공통 속성인 클래스 변수
    static int width = 100;
    static int height = 250;
}
//객체 생성
Card c = new Card(); 
//객체사용
c.kind = "HEART";
c.number = 5;
Card.width = 200;
Card.height = 300;
```
클래스 영역
- iv(인스턴스 변수) : 인스턴스가 생성되었을 때
  - 객체 : iv 여러 개 묶어둔 것이라 생각하면 쉬움~!
  - 참조변수가 없어지면 GC에 의해 자동 제거된다.
  - 개별 속성
- cv(클래스 변수) - static + iv : 클래스가 메모리에 올라갈 때
  - 공통 속성
  - 사용할 때 클래스이름.클래스변수로 사용하는 것을 권장함 ex) Card.width = 200; </br> 왜? c로 쓰면 iv로 오해할 수 있으니 구분하는 것이 좋음.

메서드 영역
- lv(지역 변수) : 변수 선언문이 수행되었을 때, 메서드 안에서 메서드 끝날 때까지만 있음.

 ------

## 메서드
1. 문장으로 묶어놓은 것(작업단위로)
2. 값(입력)을 받아서 처리하고, 결과를 반환(출력)
```java
int add(int x, int y){ //반환타입(출력) 메서드이름(매개변수선언(입력))
    int result = x + y;
    return result; //결과 반환
        }
```
매개변수는 입력을 받는 변수이다. 파라미터라고도 한다.

3. 선언부 + 구현부
- 선언부 : 반환타입 메서드이름(타입 변수명, 타입 변수명, ...)
- 구현부 : { 메서드 호출 시 수행될 코드 }
- 반환타입이 없다면 선언부 앞에 void라고 작성


### 장점
- 코드의 중복 줄임
- 코드 관리 용이
- 코드 재사용 가능
- 코드 간결해서 이해하기 쉬워짐

### 특징
- 반드시 클래스 안에 있어야한다.
- 반복적으로 수행되는 여러 문장을 메서드로 작성하는 것이 좋다.</br> 하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋다.
- 메서드 내에 선언된 변수는 지역변수(lv)!! : 메서드가 종료되면 모두 사라진다.
  - 다른 메서드 내에 있는 변수와 이름이 겹쳐도 상관없다. 왜냐? 다른 메서드이고, 그 메서드에서 종료되면 사라지기 때문에 겹치지 않는다.

### 메서드 호출
> 메서드이름(값1, 값2, ...);
```java
int result1 = add(3.5); //int add(int x, int y)를 호출하고, 결과를 result1에 저장
```

### return문

1. 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.
```java
void printGugudan(int dan){
    if(!(2 <= dan && dan <= 9))
        return; //dan이 2~9가 아닌경우, 호출한 곳으로 그냥 되돌아간다.
        }
```

2. 반환타입이 void가 아니라면 return은 생략할 수 없다! 반드시 필요하다!
3. 조건문으로 쓸 때는 참과 거짓일 때 둘 다 return문이 필요하다!

참조형 반환타입 // 객체의 주소를 반환


##static 메서드 / 인스턴스 메서드

- static 메서드(클래스 메서드)
  - 객체 생성 없이 클래스이름.메서드이름()으로 호출 가능
  - 인스턴스 멤버(iv, im)와 관련없는 작업을 하는 메서드
  - 메서드 내에서 인스턴스 변수(iv) 사용불가
- 인스턴스 메서드
  - 인스턴스 생성 후, 참조변수.메서드이름()으로 호출
  - 인스턴ㄴ스 멤버(iv, im)와 관련된 작업을 하는 메서드
  - 메서드 내에서 인스턴ㅅ느 변수(iv) 사용가능


## 호출 스택(call stack)
> 메서드 수행에 필요한 메모리가 제공되는 공간</br>
> 메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제

스택(LIFO) : 밑이 막힌 상자. 집어넣은 순서대로 위에 차곡차곡 쌓인다.

## 매개변수
기본형 매개변수 - read only
참조형 매개변수 - read & write
참조형 반환타입 - 객체의 주소를 반환

- 같은 클래스 안에서는 참조변수 없이 메서드 호출이 가능하다.
- static 메서드는 객체 생성없이 호출 가능하다.

## static 메서드(클래스 메서드)와 인스턴스 메서드
static 메서드(클래스 메서드)
- 객체 생성 없이 '클래스이름.메서드이름()'으로 호출
- 인스턴스 멤버(iv, im)와 관렵없는 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수 사용불가
  - 왜? 인스턴스 변수는 객체가 생성된 후에 사용가능한데, 생성되었는지 안되었는지 모르기 때문에 사용불가 (메서드도 마찬가지임!)
- ex) Math.random(), Math.round()
- <details>
    <summary>언제 static을 붙일까?</summary>
    - 메서드 : iv(인스턴스 변수)를 사용하지 않는 메서드에 붙인다.</br>
    - 변수 : 속성(멤버 변수) 중에서 공통 속성에 붙인다.</br>
</details>

인스턴스 메서드
- 인스턴스 생성 후, '참조변수.메서드이름()'으로 호출
- 인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드
- 메서드 내에서 인스턴스 변수(iv), 클래스 변수(cv) 둘 다 사용가능

## 오버로딩(overloading)
> 한 클래스 안에 같은 이름의 메서드 여러 개 정의하는 것 ex) println(매개변수에 따라 사용메서드 다름) </br>
- 매개변수는 다르지만 같은 의미의 기능 수행

성립조건
1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 반환 타입은 영향없다.

## 생성자
> 인스턴스가 생성될 때마다 호출되는 '인스턴스 초기화 메서드'

- 이름이 클래스 이름과 같아야 한다.
```java
클래스이름=생성자이름(타입 변수명, 타입 변수명, ...){
        //인스턴스 생성 시 수행될 코드,
        // 주로 인스턴스 변수의 초기화 코드를 적는다.
}
```
- 모든 클래스는 반드시 1개 이상 생성자를 가져야 한다.

### 기본 생성자
- 매개변수가 없는 생성자
- 클래스이름() {} : 기본생성자
  - 원래는 직접 만들어줘야하지만, 기본생성자는 컴파일러가 자동으로 추가해준다. (생성자가 하나도 없을 때만)

### 생성자 this()
> 생성자에서 다른 생성자 호출할 때 사용
- 다른 생성자 호출 시 첫 줄에서만 사용가능

### 참조변수 this
> 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
- 인스턴스 메서드(생성자 포함)에서만 사용가능 (클래스메서드에서 불

## 변수의 초기화
- 지역변수(lv)는 직접 초기화 해야한다(사용전 꼭!)
  - 왜? 메모리가 재사용이 빈번하기 때문에
  - 짧은 시간 동안 같은 공간을 여러 메서드가 사용하는데 메서드가 호출될때마다 0으로 초기화하면 성능이 떨어진다. 그래서 0으로 초기화가 아닌 새로운 값으로 덮어쓰게 초기화를 시키는 것이다.
  - 인스턴스는 오래 머물기때문에 초기화를 꼭 해줄 필요가 없는 것이다.
- 맴버변수(iv, cv)는 자동 초기화된다.(디폴트값 : false, 0. null)

### 멤버변수의 초기화
1. 명시적 초기화(=) : 대입연산자로 초기화
- 참조형 변수는 (null이나 객체주소)를 가진다. 그럼 초기화할 때는 ?
  - Engine e = new Engine(); // 객체를 만들어서 넣어줘야한다.
2. 초기화 블럭 : 복잡한 초기화
- 인스턴스 초기화 블럭 : {iv}
- 클래스 초기화 블럭 : static {cv}
3. 생성자 : iv 초기화, 복잡한 초기화

- 클래스 변수 초기화 시점 : 클래스가 처음 로딩될 때 한 번
- 인스턴스 변수 초기화 시점 : 인스턴스가 생성될 때 마다

초기화 순서 : 자동(0, null) -> 간단(=) -> 복잡(static, 생성자)

